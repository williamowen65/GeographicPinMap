<!DOCTYPE html>
<head>
  <style>
    body {
      font-family: 'Arial', sans-serif;
      margin: 0;
      padding: 0;
    }
    #container {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh; /* Full viewport height */
  }
  svg {
    max-width: 100%;
    height: auto;
  }
  </style>
</head>
<div id="container"></div>
<script src="/socket.io/socket.io.js"></script>
<script type="module">
  import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm'

  const container = d3.select('#container');
  const width = container.node().getBoundingClientRect().width;
  const height = container.node().getBoundingClientRect().height;


  const socket = io()
  const dots = []
  function addDot(coordinates) {
      // Project the coordinates.
      const [x, y] = projection(coordinates)

      // Add the dot.
      const dot = svg
        .append('circle')
        .attr('cx', x)
        .attr('cy', y)
        .attr('r', 5)
        .attr('fill', '#0d3271') // Dot color
      // .attr('fill', 'lightgreen') // Dot color

      dots.push({ dot, coordinates })
    }

  // Handle initial locations from the server
  socket.on('initialLocations', (locations) => {
    locations.forEach((location) => setTimeout(() => addDot(location), 100))
  })

  // Handle new locations broadcasted by the server
  socket.on('broadcastLocation', (location) => {
    addDot(location)
  })

  socket.on('removeLocation', (location) => {
    console.log("Removing a location because the server told us to", {location})
    const index = dots.findIndex((dot) => dot.coordinates[0] === location[0] && dot.coordinates[1] === location[1])
    if (index > -1) {
      dots[index].dot.remove()
      dots.splice(index, 1)
    }
  })

  // Declare the chart dimensions and margins.
  // const width = 960
  // const height = 600

  // Create the SVG container.
  const svg = d3
    .select('#container')
    .append('svg')
    .attr('width', '100%')
    .attr('height', height)
    .style('background-color', 'rgb(13 13 64)')
    .style('padding-top', '20px')
    .style('padding-bottom', '20px')

  // Define a projection with a -30 degree rotation.
  const projection = d3
    .geoOrthographic()
    .scale(Math.min(width, height) / 2 - 20)
    .translate([width / 2, height / 2])
    .clipAngle(90)
    .rotate([30, 0]) // Rotate the earth by -30 degrees

  // Create a light light blue circle behind the earth.
  const backgroundCircle = svg
    .append('circle')
    .attr('cx', width / 2)
    .attr('cy', height / 2)
    .attr('r', projection.scale())
    .attr('fill', '#E0F7FA') // Ocean color

  // Define a path generator.
  const path = d3.geoPath().projection(projection)

  // Load and display the world map.
  d3.json(
    'https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson'
  ).then(function (data) {
    svg
      .append('g')
      .selectAll('path')
      .data(data.features)
      .enter()
      .append('path')
      .attr('d', path)
      .attr('fill', '#ADD8E6') // Land color
      .attr('stroke', '#0000FF') // Border color
      .attr('stroke-width', 1)
      // Add country names
      .append('title')
      .text((d) => d.properties.name)

    // Add a button to the SVG container.
    const button = svg
      .append('foreignObject')
      .attr('x', width - 150)
      .attr('y', 20)
      .attr('width', 130)
      .attr('height', 40)
      .append('xhtml:div')
      .append('button')
      .attr('id', 'svg-share-location')
      .style('width', '100%')
      .style('height', '100%')
      .text('Add Location')

    // Add event listener to the new button.
    document
      .querySelector('#svg-share-location')
      .addEventListener('click', () => {
        // prompt browser for location data
        navigator.geolocation.getCurrentPosition((position) => {
          const { latitude, longitude } = position.coords
          const location = [longitude, latitude]
          coordinates.push(location)
          addDot(location)

          // Send the new location to the server
          socket.emit('newLocation', location)
        })
      })

    
    const coordinates = [[-122.4194, 37.7749]]
    const additionalCoordinates = [
      [2.3522, 48.8566], // Paris
      [139.6917, 35.6895], // Tokyo
      [151.2093, -33.8688], // Sydney
      [12.4964, 41.9028], // Rome
      [77.209, 28.6139], // New Delhi
      [-120.7401, 47.7511], // Washington State
      [-122.3321, 47.6062], // Seattle
      [-122.6765, 45.5234], // Portland
      [-117.426, 47.6588], // Spokane
    ]

    coordinates.forEach(addDot)

    

    // Set up rotation parameters.
    let rotate = [0, 0]
    const velocity = 0.4
    // Set the initial rotation to match the natural angle of the earth.
    // projection.rotate([0, -30])

    // Function to update the rotation.
    function updateRotation() {
      rotate[0] += velocity
      projection.rotate([rotate[0], -30])
      svg.selectAll('path').attr('d', path)
      // console.log({ dots })
      dots.forEach(({ coordinates, dot }) => {
        // console.log({ coordinates, dot })
        const [newX, newY] = projection(coordinates)
        const isVisible =
          projection.clipAngle() * (Math.PI / 180) >
          d3.geoDistance(
            coordinates,
            projection.invert([width / 2, height / 2])
          )
        dot
          .attr('cx', newX)
          .attr('cy', newY)
          .attr('display', isVisible ? 'block' : 'none')
      })
      requestAnimationFrame(updateRotation)
    }

    // Start the rotation.
    updateRotation()
  })
</script>

